/*
 * Copyright 2020 The Embulk project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.embulk.util.config;

import com.fasterxml.jackson.databind.node.ObjectNode;
import org.embulk.config.TaskSource;

/**
 * A task-defining interface that is mapped from {@code org.embulk.config.ConfigSource} and {@code org.embulk.config.TaskSource}.
 *
 * <p>Embulk plugins usually need to define their own interface extending this {@link Task}. Then,
 * {@code org.embulk.config.ConfigSource} and {@code org.embulk.config.TaskSource} are mapped into
 * the extended interface with {@link ConfigMapper} and {@link TaskMapper}, respectively. See the
 * example below.
 *
 * <pre><code> public class ExampleInputPlugin implements InputPlugin {
 *     public ExampleInputPlugin() {
 *         this.configMapperFactory = org.embulk.util.config.ConfigMapperFactory.withDefault();
 *     }
 *
 *     public interface PluginTask extends org.embulk.util.config.Task {
 *        {@literal @}Config("config")
 *         String getConfigAsString();
 *
 *        {@literal @}Config("config")
 *         int getConfigAsInteger();
 *
 *        {@literal @}Config("someone")
 *        {@literal @}ConfigDefault("any")
 *         String getSomeone();
 *     }
 *
 *     public ConfigDiff transaction(final ConfigSource config, final InputPlugin.Control control) {
 *         final org.embulk.util.config.ConfigMapper configMapper = this.configMapperFactory.createConfigMapper();
 *         final PluginTask task = configMapper.map(config, PluginTask.class);
 *         // ...
 *     }
 *
 *     public TaskReport run(TaskSource taskSource, Schema schema, int taskIndex, PageOutput output) {
 *         final org.embulk.util.config.TaskMapper taskMapper = this.configMapperFactory.createTaskMapper();
 *         final PluginTask task = taskMapper.map(taskSource, PluginTask.class);
 *         // ...
 *     }
 *
 *     // ...
 *
 *     private org.embulk.util.config.ConfigMapperFactory configMapperFactory;
 * }</code></pre>
 *
 * <h3>For core developers</h3>
 *
 * <p>The {@link Task} object generated by {@link ConfigMapper} and {@link TaskMapper} is implemented
 * with {@link java.lang.reflect.Proxy}, the dynamic proxy mechanism with reflection.
 */
public interface Task {
    /**
     * Validates this {@link Task} with a {@link javax.validation.Validator} registered from {@link ConfigMapperFactory}.
     *
     * @throws TaskValidationException  if this {@link Task} is invalid
     */
    void validate();

    // TODO public void validateConfig();
    // ConfigSource.loadTask calls validateConfig and it validates only fields that have Config annotation

    /**
     * Dumps this {@link Task} as a {@code org.embulk.config.TaskSource}.
     *
     * @return {@code org.embulk.config.TaskSource} dumped
     * @deprecated Replaced with {@link #toTaskSource}.
     */
    @Deprecated
    TaskSource dump();

    /**
     * Dumps this {@link Task} as a {@code org.embulk.config.TaskSource}.
     *
     * @return {@code org.embulk.config.TaskSource} dumped
     */
    TaskSource toTaskSource();

    /**
     * Dumps this {@link Task} as a {@link com.fasterxml.jackson.databind.node.ObjectNode}.
     *
     * @return {@link com.fasterxml.jackson.databind.node.ObjectNode} dumped
     */
    ObjectNode toObjectNode();
}
